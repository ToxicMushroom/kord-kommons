package me.melijn.apredgres.tablemodelimport com.google.devtools.ksp.*import com.google.devtools.ksp.processing.*import com.google.devtools.ksp.symbol.*import me.melijn.apredgres.ExposedIndeximport me.melijn.apredgres.util.ExposedParsers.getValueGetterimport me.melijn.apredgres.util.Reflectionsimport me.melijn.apredgres.util.Reflections.getAutoIncrementingimport me.melijn.apredgres.util.Reflections.getIndexesimport me.melijn.apredgres.util.Reflections.getParametersFromPropertiesimport me.melijn.apredgres.util.Reflections.getSanitizedNameFromIndeximport me.melijn.apredgres.util.Reflections.getTypeimport me.melijn.apredgres.util.appendLineimport me.melijn.apredgres.util.appendTextimport me.melijn.kordkommons.utils.TimeUtilimport me.melijn.kordkommons.utils.UUIDUtilimport org.intellij.lang.annotations.Languageimport java.io.OutputStreamimport java.util.*import kotlin.time.Durationinternal class TableModelProcessor(    val codeGenerator: CodeGenerator,    val logger: KSPLogger,    val location: String,    val globalKeyPrefix: String) : SymbolProcessor {    private val cacheableFile = codeGenerator.createNewFile(        Dependencies(false),        location, "CacheExtensions"    )    val imports = HashSet<String>()    val sb = StringBuilder()    init {        imports.addAll(            """                import kotlinx.serialization.*                import org.jetbrains.exposed.sql.ResultRow            """.trimIndent().split("\n")        )    }    @OptIn(KspExperimental::class)    override fun process(resolver: Resolver): List<KSAnnotated> {        val symbols = resolver.getSymbolsWithAnnotation(TableModel::class.java.name).toList()        val ret = symbols.filter { !it.validate() }.toList()        symbols            .filter { symbol -> symbol is KSClassDeclaration && symbol.validate() }            .forEach { symbol ->                val cacheables = symbol.getAnnotationsByType(TableModel::class)                val cacheableSettings = cacheables.first()                symbol.accept(InjectorVisitor(cacheableSettings), Unit)            }        if (symbols.isNotEmpty()) {            cacheableFile.appendLine("package $location")            cacheableFile.appendText(imports.joinToString("\n"))            cacheableFile.appendText(sb.toString())            cacheableFile.close()        }        return ret    }    inner class InjectorVisitor(private val tableModelSettings: TableModel) : KSVisitorVoid() {        private var indexCount = -1        private lateinit var classKeyPrefix: String        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {            val simpleName = classDeclaration.simpleName.asString()            val name = classDeclaration.packageName.asString() + ".${simpleName}"            classKeyPrefix = "$globalKeyPrefix${simpleName.lowercase()}"            val properties = classDeclaration.getDeclaredProperties()                .filter { it.simpleName.asString() != "primaryKey" }            val pkeyProperty: KSPropertyDeclaration = classDeclaration.getDeclaredProperties().first {                it.type.resolve().toString() == "PrimaryKey"            }            val indexes = getIndexes(classDeclaration)            val autoIncrementing = getAutoIncrementing(classDeclaration)            val fieldList = Reflections.getFields(pkeyProperty)            val pkeyProperties = classDeclaration.getDeclaredProperties()                .filter { it.simpleName.asString() != "primaryKey" }                .filter { fieldList.contains(it.simpleName.asString()) }            // imports for the data classes file            val propertyImports = properties.joinToString("\n") {                "import " + getType(it, simple = false, removeNullable = true)            }            @Language("kotlin")            val text = """import $name$propertyImports            """.split("\n")            imports.addAll(text)            sb.appendLine("// fieldList: $fieldList")            sb.appendLine("// autoIncrementing: $autoIncrementing")            /** Cache object class **/            sb.appendLine("@Serializable")            sb.appendLine("data class ${simpleName}Data(")            sb.appendLine(properties.joinToString(",\n") {                val type = getType(it, true)                val serializerFQName = when (type) {                    Duration::class.java.name, Duration::class.java.simpleName ->                        TimeUtil.DurationSerializer::class.java.canonicalName                    UUID::class.java.name, UUID::class.java.simpleName ->                        UUIDUtil.UUIDSerializer::class.java.canonicalName                    else -> ""                }                val annotation = if (serializerFQName.isNotBlank()) {                    "@Serializable(with = $serializerFQName::class)"                } else ""                @Language("kotlin")                val code = "    var ${it.simpleName.asString()}: $type"                if (annotation.isNotBlank()) {                    "    $annotation\n$code"                } else code            })            sb.appendLine(") {")            sb.appendLine("    companion object {")            addFromResRowFunction(simpleName, properties)            sb.appendLine("    }")            sb.appendLine("}\n")            val abstractPkg = "$location.database.manager"            val abstractMgrName = "Abstract${simpleName}Manager"            val dependencies = Dependencies(false)            val abstractManager = codeGenerator.createNewFile(dependencies, abstractPkg, abstractMgrName)            val dbFieldTypeImports = buildSet {                properties.forEach {                    add("import " + getType(it, false, removeNullable = true))                }            }.joinToString("\n")            /** Do abstract mgr imports **/            abstractManager.appendLine(                """package $abstractPkgimport java.util.concurrent.TimeUnitimport me.melijn.kordkommons.database.DBTableManagerimport me.melijn.kordkommons.database.insertOrUpdateimport me.melijn.kordkommons.database.DriverManagerimport $location.${simpleName}Dataimport org.jetbrains.exposed.sql.insertimport org.jetbrains.exposed.sql.selectimport org.jetbrains.exposed.sql.andimport org.jetbrains.exposed.sql.deleteWhereimport org.jetbrains.exposed.sql.insertIgnoreimport org.jetbrains.exposed.sql.SqlExpressionBuilder.eqimport $nameimport kotlinx.serialization.*import kotlinx.serialization.json.*$dbFieldTypeImports            """.trimIndent()            )            abstractManager.appendLine("open class Abstract${simpleName}Manager(override val driverManager: DriverManager) : DBTableManager<${simpleName}>(driverManager, ${simpleName}) {")            abstractManager.appendLine("    val classKeyPrefix = \"$classKeyPrefix\"")            addGetRawByIdMethod(abstractManager, pkeyProperties, simpleName)            if (pkeyProperties.count() > 0) {                addGetByIdMethod(abstractManager, pkeyProperties, simpleName)                addDeleteByIdMethod(abstractManager, pkeyProperties, simpleName)                addDeleteForwardByIdMethod(abstractManager, simpleName, pkeyProperties)                // index on all fields            } else if (indexes.any { fieldList.size == it.fields.size }) {                val index = indexes.first { fieldList.size == it.fields.size }                addDeleteForwardByIndexMethod(abstractManager, simpleName, index)            }            addStoreMethod(abstractManager, pkeyProperties, simpleName, properties)            for (index in indexes) {                indexCount++                // TODO: can we make these caching ?                addGetByIndexMethod(abstractManager, simpleName, properties, index)                addDeleteByIndexMethod(abstractManager, simpleName, properties, index)            }            if (autoIncrementing.isNotEmpty()) {                addInsertAndGetKeyMethod(abstractManager, simpleName, autoIncrementing, properties)            }            abstractManager.appendLine("}")            abstractManager.close()        }        private fun addInsertAndGetKeyMethod(            abstractManager: OutputStream,            simpleName: String,            autoIncrementing: List<String>,            properties: Sequence<KSPropertyDeclaration>        ) {            val propertyNoIncrements = properties.filterNot {                autoIncrementing.contains(it.simpleName.asString())            }            val propertyNoIncNames = propertyNoIncrements.map { it.simpleName.asString() }            val args = propertyNoIncrements.joinToString() {                val type = Reflections.getType(it, true)                val postfix = if (type.endsWith("?")) " = null" else ""                it.simpleName.asString() + ": " + type + postfix            }            @Language("kotlin")            val str = """    /**     * Insert a row, autoincrementing columns cannot be provided but will be returned.     *      * @return [${simpleName}Data] includes the generated key(s)     */    suspend fun insertAndGetRow(${args}): ${simpleName}Data {        return scopedTransaction {            val resultedValues = ${simpleName}.insert {${propertyNoIncNames.joinToString("\n") { " ".repeat(4 * 4) + "it[${simpleName}.${it}] = $it" }}            }.resultedValues            val resRow1 = resultedValues?.get(0)!!            val resRow = ${simpleName}Data.fromResRow(resRow1)            resRow        }    }"""            abstractManager.appendText(str)        }        private fun addFromResRowFunction(            simpleName: String,            properties: Sequence<KSPropertyDeclaration>        ) {            val resRowGetters = properties.joinToString(",\n") { propertyDecl ->                val propertyName = propertyDecl.simpleName.asString()                " ".repeat(16) + "resRow[$simpleName." + propertyName + "]${getValueGetter(propertyDecl)}"            }            @Language("kotlin")            val text = """        fun fromResRow(resRow: ResultRow): ${simpleName}Data {            return ${simpleName}Data($resRowGetters            )        }"""            sb.appendLine(text)        }        private fun addStoreMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            simpleName: String,            properties: Sequence<KSPropertyDeclaration>        ) {            val propertyNames = properties.map { it.simpleName.asString() }            val pkeyNames = pkeyProperties.map { it.simpleName.asString() }            val propertyNoKeys = propertyNames.filterNot { pkeyNames.contains(it) }            val pkeyKeyPart = pkeyNames.joinToString(":") { "\${data.$it}" } // ${id1}:${id2}:...            val cachingLines = if (tableModelSettings.cacheable)                """val cachableStr = Json.encodeToString(data)        val key = "$classKeyPrefix:${pkeyKeyPart}"        driverManager.setCacheEntry(key, cachableStr, ${tableModelSettings.ttl}, TimeUnit.SECONDS)"""            else ""            val updateMethod = if (propertyNoKeys.any()) {                """${simpleName}.insertOrUpdate({${propertyNames.joinToString("\n") { " ".repeat(4 * 4) + "it[${simpleName}.${it}] = data.${it}" }}            }, {${propertyNoKeys.joinToString("\n") { " ".repeat(4 * 4) + "it[${simpleName}.${it}] = data.${it}" }}            })"""            } else {                """${simpleName}.insertIgnore {${propertyNames.joinToString("\n") { " ".repeat(4 * 4) + "it[${simpleName}.${it}] = data.${it}" }}            }"""            }            @Language("kotlin")            val str = """    suspend fun store(data: ${simpleName}Data) {        scopedTransaction {            $updateMethod        }        $cachingLines    }"""            abstractManager.appendText(str)        }        private fun addGetByIdMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            simpleName: String        ) {            val pKeyParams = getParametersFromProperties(pkeyProperties)            val pkeyNames = pkeyProperties.map { it.simpleName.asString() }            val pkeyKeyPart = pkeyNames.joinToString(":") { "\${$it}" } // ${id1}:${id2}:...            @Language("kotlin")            val fetchLine = """                val cachable = getRawById(${pkeyNames.joinToString(", ")})            """.trimIndent()            val bodyLines = if (tableModelSettings.cacheable) {                val cacheRefreshOptions = if (tableModelSettings.refreshCacheOnFetch)                    ", ${tableModelSettings.ttl}, TimeUnit.SECONDS" else                    ""                @Language("kotlin")                val cacheLines = """        val key = "$classKeyPrefix:${pkeyKeyPart}"        driverManager.getCacheEntry(key${cacheRefreshOptions})?.run {            if (this == "null") return null            return Json.decodeFromString<${simpleName}Data>(this)        }        $fetchLine        val cachableStr = Json.encodeToString(cachable)        driverManager.setCacheEntry(key, cachableStr, ${tableModelSettings.ttl}, TimeUnit.SECONDS)"""                cacheLines            } else {                " ".repeat(8) + fetchLine            }            @Language("kotlin")            val code = """    suspend fun getById($pKeyParams): ${simpleName}Data? {$bodyLines        return cachable    }"""            abstractManager.appendText(code)        }        private fun addGetRawByIdMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            simpleName: String        ) {            val pKeyParams = getParametersFromProperties(pkeyProperties)            @Language("kotlin")            val str = """    suspend fun getRawById(${pKeyParams}): ${simpleName}Data? {        return scopedTransaction {            ${simpleName}.select {                ${pkeyProperties.joinToString(".and") { "(${simpleName}.$it.eq($it))" }}            }.firstOrNull()?.let {                ${simpleName}Data.fromResRow(it)            }        }    } """            abstractManager.appendText(str)        }        private fun addDeleteByIdMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            name: String        ) {            val pKeyParams = getParametersFromProperties(pkeyProperties)            val pkeyNames = pkeyProperties.map { it.simpleName.asString() }            val pkeyKeyPart = pkeyNames.joinToString(":") { "\${$it}" } // ${id1}:${id2}:...            @Language("kotlin")            val delete = """        val res = scopedTransaction {            ${name}.deleteWhere {                ${pkeyProperties.joinToString(".and") { "(${name}.$it.eq($it))" }}            }        }"""            val body = if (tableModelSettings.cacheable) {                """        val key = "$classKeyPrefix:${pkeyKeyPart}"$delete        driverManager.removeCacheEntry(key)"""            } else {                delete            }            @Language("kotlin")            val str = """    suspend fun deleteById(${pKeyParams}): Int {$body        return res    }"""            abstractManager.appendText(str)        }        private fun addDeleteForwardByIdMethod(            abstractManager: OutputStream,            simpleName: String,            pkeyProperties: Sequence<KSPropertyDeclaration>,        ) {            @Language("kotlin")            val str = """    suspend fun delete(data: ${simpleName}Data): Int {        return deleteById(${pkeyProperties.joinToString { "data.${it.simpleName.asString()}" }})    }"""            abstractManager.appendText(str)        }        private fun addDeleteForwardByIndexMethod(            abstractManager: OutputStream,            simpleName: String,            index: ExposedIndex        ) {            val sanitizedName = getSanitizedNameFromIndex(index, indexCount)            @Language("kotlin")            val str = """    suspend fun delete(data: ${simpleName}Data): Int {        return deleteBy${sanitizedName}(${index.fields.joinToString { "data.${it}" }})    }"""            abstractManager.appendText(str)        }        private fun addGetByIndexMethod(            abstractManager: OutputStream,            simpleName: String,            properties: Sequence<KSPropertyDeclaration>,            index: ExposedIndex        ) {            val indexedProperties = properties.filter {                index.fields.contains(it.simpleName.asString())            }            val params = getParametersFromProperties(indexedProperties)            val sanitizedName = getSanitizedNameFromIndex(index, indexCount)            val returnType = if (index.unique) "${simpleName}Data?" else                "List<${simpleName}Data>"            val takeFirstWhenUnique = if (index.unique) "firstOrNull"            else "toList"            @Language("kotlin")            val text = """    // index fields: ${index.fields.joinToString()}    // properties: ${properties.joinToString()}    suspend fun getBy${sanitizedName}(${params}): $returnType {        return scopedTransaction {            ${simpleName}.select {                ${indexedProperties.joinToString(".and") { "(${simpleName}.$it.eq($it))" }}            }.asSequence().map {                ${simpleName}Data.fromResRow(it)            }.${takeFirstWhenUnique}()        }    }"""            abstractManager.appendText(text)        }        private fun addDeleteByIndexMethod(            abstractManager: OutputStream,            simpleName: String,            properties: Sequence<KSPropertyDeclaration>,            index: ExposedIndex        ) {            val indexedProperties = properties.filter {                index.fields.contains(it.simpleName.asString())            }            val params = Reflections.getParametersFromProperties(indexedProperties)            val sanitizedName = getSanitizedNameFromIndex(index, indexCount)            @Language("kotlin")            val text = """    // index fields: ${index.fields.joinToString()}    // properties: ${properties.joinToString()}    suspend fun deleteBy${sanitizedName}(${params}): Int {        return scopedTransaction {            ${simpleName}.deleteWhere {                ${indexedProperties.joinToString(".and") { "(${simpleName}.$it.eq($it))" }}            }        }    }"""            abstractManager.appendText(text)        }        override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {        }    }}