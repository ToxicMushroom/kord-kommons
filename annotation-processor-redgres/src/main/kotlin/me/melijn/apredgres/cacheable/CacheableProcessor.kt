package me.melijn.apredgres.cacheableimport com.google.devtools.ksp.*import com.google.devtools.ksp.processing.*import com.google.devtools.ksp.symbol.*import me.melijn.apredgres.util.Reflectionsimport me.melijn.apredgres.util.appendLineimport me.melijn.apredgres.util.appendTextimport me.melijn.kordkommons.utils.TimeUtilimport me.melijn.kordkommons.utils.UUIDUtilimport me.melijn.kordkommons.utils.removeimport me.melijn.kordkommons.utils.removeFirstimport org.intellij.lang.annotations.Languageimport java.io.OutputStreamimport java.lang.IllegalStateExceptionimport java.util.*import kotlin.collections.HashSetimport kotlin.time.Durationinternal class CacheableProcessor(    val codeGenerator: CodeGenerator,    val logger: KSPLogger,    val location: String,    val globalKeyPrefix: String) : SymbolProcessor {    private val cacheableFile = codeGenerator.createNewFile(        Dependencies(false),        location, "CacheExtensions"    )    val imports = HashSet<String>()    val sb = StringBuilder()    init {        imports.addAll(            """                import kotlinx.serialization.*                import org.jetbrains.exposed.sql.ResultRow            """.trimIndent().split("\n")        )    }    @OptIn(KspExperimental::class)    override fun process(resolver: Resolver): List<KSAnnotated> {        val symbols = resolver.getSymbolsWithAnnotation(Cacheable::class.java.name).toList()        val ret = symbols.filter { !it.validate() }.toList()        symbols            .filter { symbol -> symbol is KSClassDeclaration && symbol.validate() }            .forEach { symbol ->                val cacheables = symbol.getAnnotationsByType(Cacheable::class)                val cacheableSettings = cacheables.first()                symbol.accept(InjectorVisitor(cacheableSettings), Unit)            }        if (symbols.isNotEmpty()) {            cacheableFile.appendLine("package $location")            cacheableFile.appendText(imports.joinToString("\n"))            cacheableFile.appendText(sb.toString())            cacheableFile.close()        }        return ret    }    inner class InjectorVisitor(val cacheableSettings: Cacheable) : KSVisitorVoid() {        var indexCount = -1        lateinit var classKeyPrefix: String        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {            val simpleName = classDeclaration.simpleName.asString()            val name = classDeclaration.packageName.asString() + ".${simpleName}"            classKeyPrefix = "$globalKeyPrefix${simpleName.lowercase()}"            val properties = classDeclaration.getDeclaredProperties()                .filter { it.simpleName.asString() != "primaryKey" }            val pkeyProperty: KSPropertyDeclaration = classDeclaration.getDeclaredProperties().first {                it.type.resolve().toString() == "PrimaryKey"            }            val indexes = getIndexes(classDeclaration)            val autoIncrementing = getAutoIncrementing(classDeclaration)            /** janky hack part, don't touch unless it broke pls **/            val field = pkeyProperty.javaClass.getDeclaredField("propertyDescriptor\$delegate")            field.isAccessible = true            val lazyPropertyDesciptor = field.get(pkeyProperty)            val lazyValueMethod = Lazy::class.java.getMethod("getValue")            val lazyValue = lazyValueMethod.invoke(lazyPropertyDesciptor)            val propertyDescriptor = lazyValue            val aaaa = lazyValue::class.java.getMethod("getSource").invoke(propertyDescriptor)            val fish = aaaa::class.java.getMethod("getPsi").invoke(aaaa)            val lastChildField = fish::class.java.getMethod("getLastChild")            val firstChildField = fish::class.java.getMethod("getFirstChild")            val last1 = lastChildField.invoke(fish)            val last2 = lastChildField.invoke(last1)            var invokeEl = firstChildField.invoke(last2)            val fieldList = mutableListOf<String>()            while (invokeEl != null) {                val nextSiblingField = invokeEl::class.java.getMethod("getNextSibling")                val type = invokeEl.toString()                if (type == "VALUE_ARGUMENT") {                    val first2 = firstChildField.invoke(invokeEl)                    val first3 = firstChildField.invoke(first2)                    val text = first3::class.java.getMethod("getText").invoke(first3)                    fieldList.add(text.toString())                }                invokeEl = try {                    nextSiblingField.invoke(invokeEl)                } catch (t: Throwable) {                    null                }            }            val pkeyProperties = classDeclaration.getDeclaredProperties()                .filter { it.simpleName.asString() != "primaryKey" }                .filter { fieldList.contains(it.simpleName.asString()) }            // imports for the data classes file            val propertyImports = properties.joinToString("\n") {                "import " + getType(it, simple = false, removeNullable = true)            }            @Language("kotlin")            val text = """import $name$propertyImports            """.split("\n")            imports.addAll(text)            sb.appendLine("// fieldList: $fieldList")            sb.appendLine("// autoIncrementing: $autoIncrementing")            /** Cache object class **/            sb.appendLine("@Serializable")            sb.appendLine("data class ${simpleName}Data(")            sb.appendLine(properties.joinToString(",\n") {                val type = getType(it, true)                val serializerFQName = when (type) {                    Duration::class.java.name, Duration::class.java.simpleName ->                        TimeUtil.DurationSerializer::class.java.canonicalName                    UUID::class.java.name, UUID::class.java.simpleName ->                        UUIDUtil.UUIDSerializer::class.java.canonicalName                    else -> ""                }                val annotation = if (serializerFQName.isNotBlank()) {                    "@Serializable(with = $serializerFQName::class)"                } else ""                @Language("kotlin")                val code = "    var ${it.simpleName.asString()}: $type"                if (annotation.isNotBlank()) {                    "    $annotation\n$code"                } else code            })            sb.appendLine(") {")            sb.appendLine("    companion object {")            addFromResRowFunction(simpleName, properties)            sb.appendLine("    }")            sb.appendLine("}\n")            val abstractPkg = "$location.database.manager"            val abstractMgrName = "Abstract${simpleName}Manager"            val dependencies = Dependencies(false)            val abstractManager = codeGenerator.createNewFile(dependencies, abstractPkg, abstractMgrName)            val dbFieldTypeImports = buildSet {                properties.forEach {                    add("import " + getType(it, false, removeNullable = true))                }            }.joinToString("\n")            /** Do abstract mgr imports **/            abstractManager.appendLine(                """package $abstractPkgimport java.util.concurrent.TimeUnitimport me.melijn.kordkommons.database.DBTableManagerimport me.melijn.kordkommons.database.insertOrUpdateimport me.melijn.kordkommons.database.DriverManagerimport $location.${simpleName}Dataimport org.jetbrains.exposed.sql.selectimport org.jetbrains.exposed.sql.andimport org.jetbrains.exposed.sql.deleteWhereimport org.jetbrains.exposed.sql.SqlExpressionBuilder.eqimport $nameimport kotlinx.serialization.*import kotlinx.serialization.json.*$dbFieldTypeImports            """.trimIndent()            )            abstractManager.appendLine("open class Abstract${simpleName}Manager(override val driverManager: DriverManager) : DBTableManager<${simpleName}>(driverManager, ${simpleName}) {")            abstractManager.appendLine("    val classKeyPrefix = \"$classKeyPrefix\"")            addGetByIdMethod(abstractManager, pkeyProperties, simpleName)            addGetCachedByIdMethod(abstractManager, pkeyProperties, simpleName)            addDeleteByIdMethod(abstractManager, pkeyProperties, simpleName)            addDeleteEntryMethod(abstractManager, simpleName, pkeyProperties)            addStoreMethod(abstractManager, pkeyProperties, simpleName, properties)            for (index in indexes) {                indexCount++                addGetByIndexMethod(abstractManager, simpleName, properties, index)                addDeleteByIndexMethod(abstractManager, simpleName, properties, index)            }            abstractManager.appendLine("}")            abstractManager.close()        }        private fun addFromResRowFunction(            simpleName: String,            properties: Sequence<KSPropertyDeclaration>        ) {            val resRowGetters = properties.joinToString(",\n") { propertyDecl ->                val propertyName = propertyDecl.simpleName.asString()                " ".repeat(16) + "resRow[$simpleName." + propertyName + "]${getValueGetter(propertyDecl)}"            }            @Language("kotlin")            val text = """        fun fromResRow(resRow: ResultRow): ${simpleName}Data {            return ${simpleName}Data($resRowGetters            )        }"""            sb.appendLine(text)        }        private fun getAutoIncrementing(model: KSClassDeclaration): List<String> {            val code = Reflections.getCode(model)            val results = "\\.autoIncrement\\(".toRegex().findAll(code).toList()            val propPattern = "va[lr]\\s+(\\w+)".toRegex()            var prev = 0            val props = mutableListOf<String>()            for (res in results) {                val searchFrom = res.range.first                val prop = propPattern.findAll(code.substring(prev, searchFrom)).lastOrNull() ?: run {                    throw IllegalStateException("Found .autoIncrement( but no property before it")                }                props.add(prop.groups[1]!!.value)                prev = searchFrom            }            return props        }        private fun getIndexes(model: KSClassDeclaration): List<ExposedIndex> {            val preCode = Reflections.getCode(model)            val indexLines = preCode.lines().filter { it.contains("index(") }            val indexes = mutableListOf<ExposedIndex>()            for (index in indexLines) {                if (index.startsWith("//")) continue                val args = index.trim()                    .removeFirst("//.*".toRegex())                    .removeFirst("index(")                    .trim()                    .dropLast(1) // removes the last ")"                    .split("\\s*,\\s*".toRegex())                fun parseName(): String? {                    val nameOverride: String =                        "//\\s*name\\s*=\\s*(.*)".toRegex().find(index)?.groups?.get(1)?.value ?: ""                    return nameOverride.takeIf { it.isNotBlank() } ?: args.drop(0).firstOrNull { it.contains("\"") }                }                val name = parseName()                val argsNoName = args.filterNot { it == name }                val bool = argsNoName.firstOrNull { it == "true" || it == "false" }?.toBoolean() ?: false                val fields = argsNoName.filterNot { it == "true" || it == "false" }                indexes.add(ExposedIndex(bool, fields, name))            }            return indexes        }        private fun addStoreMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            simpleName: String,            properties: Sequence<KSPropertyDeclaration>        ) {            val propertyNames = properties.map { it.simpleName.asString() }            val pkeyNames = pkeyProperties.map { it.simpleName.asString() }            val propertyNoKeys = propertyNames.filterNot { pkeyNames.contains(it) }            val pkeyKeyPart = pkeyNames.joinToString(":") { "\${data.$it}" } // ${id1}:${id2}:...            @Language("kotlin")            val str = """    fun store(data: ${simpleName}Data) {        val key = "$classKeyPrefix:${pkeyKeyPart}"        scopedTransaction {            ${simpleName}.insertOrUpdate({${propertyNames.joinToString("\n") { " ".repeat(4 * 4) + "it[${simpleName}.${it}] = data.${it}" }}            }, {${propertyNoKeys.joinToString("\n") { " ".repeat(4 * 4) + "it[${simpleName}.${it}] = data.${it}" }}            })        }        val cachableStr = Json.encodeToString(data)        driverManager.setCacheEntry(key, cachableStr, ${cacheableSettings.ttl}, TimeUnit.SECONDS)    }"""            abstractManager.appendText(str)        }        private fun addGetCachedByIdMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            simpleName: String        ) {            val pKeyParams = getParametersFromProperties(pkeyProperties)            val pkeyNames = pkeyProperties.map { it.simpleName.asString() }            val pkeyKeyPart = pkeyNames.joinToString(":") { "\${$it}" } // ${id1}:${id2}:...            val cacheRefreshOptions =                if (cacheableSettings.refreshCacheOnFetch) ", ${cacheableSettings.ttl}, TimeUnit.SECONDS" else ""            @Language("kotlin")            val code = """    suspend fun getCachedById($pKeyParams): ${simpleName}Data? {        val key = "$classKeyPrefix:${pkeyKeyPart}"        driverManager.getCacheEntry(key${cacheRefreshOptions})?.run {            if (this == "null") return null            return Json.decodeFromString<${simpleName}Data>(this)        }        val cachable = getById(${pkeyNames.joinToString(", ")})        val cachableStr = Json.encodeToString(cachable)        driverManager.setCacheEntry(key, cachableStr, ${cacheableSettings.ttl}, TimeUnit.SECONDS)        return cachable    }"""            abstractManager.appendText(code)        }        private fun addGetByIdMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            simpleName: String        ) {            val pKeyParams = getParametersFromProperties(pkeyProperties)            @Language("kotlin")            val str = """    fun getById(${pKeyParams}): ${simpleName}Data? {        return scopedTransaction {            ${simpleName}.select {                ${pkeyProperties.joinToString(".and") { "(${simpleName}.$it.eq($it))" }}            }.firstOrNull()?.let {                ${simpleName}Data.fromResRow(it)            }        }    } """            abstractManager.appendText(str)        }        private fun addDeleteByIdMethod(            abstractManager: OutputStream,            pkeyProperties: Sequence<KSPropertyDeclaration>,            name: String        ) {            val pKeyParams = getParametersFromProperties(pkeyProperties)            val pkeyNames = pkeyProperties.map { it.simpleName.asString() }            val pkeyKeyPart = pkeyNames.joinToString(":") { "\${$it}" } // ${id1}:${id2}:...            @Language("kotlin")            val str = """    fun deleteById(${pKeyParams}): Int {        val key = "$classKeyPrefix:${pkeyKeyPart}"        val res = scopedTransaction {             ${name}.deleteWhere {                 ${pkeyProperties.joinToString(".and") { "(${name}.$it.eq($it))" }}             }        }        driverManager.removeCacheEntry(key)        return res    }"""            abstractManager.appendText(str)        }        private fun addDeleteEntryMethod(            abstractManager: OutputStream,            simpleName: String,            pkeyProperties: Sequence<KSPropertyDeclaration>,        ) {            @Language("kotlin")            val str = """    fun delete(data: ${simpleName}Data): Int {        return deleteById(${pkeyProperties.joinToString { "data.${it.simpleName.asString()}" }})    }"""            abstractManager.appendText(str)        }        private fun addGetByIndexMethod(            abstractManager: OutputStream,            simpleName: String,            properties: Sequence<KSPropertyDeclaration>,            index: ExposedIndex        ) {            val indexedProperties = properties.filter {                index.fields.contains(it.simpleName.asString())            }            val params = getParametersFromProperties(indexedProperties)            val returnType = if (index.unique) "${simpleName}Data?" else                "List<${simpleName}Data>"            val sanitizedName = index.name                ?.remove("\"")                ?.replace("_(.)".toRegex()) { res -> res.groupValues[1].uppercase() }                ?.replaceFirstChar { it.uppercase() } ?: "Index$indexCount"            val takeFirstWhenUnique = if (index.unique) "firstOrNull"            else "toList"            @Language("kotlin")            val text = """    // index fields: ${index.fields.joinToString()}    // properties: ${properties.joinToString()}    fun getBy${sanitizedName}(${params}): $returnType {        return scopedTransaction {            ${simpleName}.select {                ${indexedProperties.joinToString(".and") { "(${simpleName}.$it.eq($it))" }}            }.asSequence().map {                ${simpleName}Data.fromResRow(it)            }.${takeFirstWhenUnique}()        }    }"""            abstractManager.appendText(text)        }        private fun addDeleteByIndexMethod(            abstractManager: OutputStream,            simpleName: String,            properties: Sequence<KSPropertyDeclaration>,            index: ExposedIndex        ) {            val indexedProperties = properties.filter {                index.fields.contains(it.simpleName.asString())            }            val params = getParametersFromProperties(indexedProperties)            val sanitizedName = index.name                ?.remove("\"")                ?.replace("_(.)".toRegex()) { res -> res.groupValues[1].uppercase() }                ?.replaceFirstChar { it.uppercase() } ?: "Index$indexCount"            @Language("kotlin")            val text = """    // index fields: ${index.fields.joinToString()}    // properties: ${properties.joinToString()}    fun deleteBy${sanitizedName}(${params}): Int {        return scopedTransaction {             ${simpleName}.deleteWhere {                 ${indexedProperties.joinToString(".and") { "(${simpleName}.$it.eq($it))" }}             }         }    }"""            abstractManager.appendText(text)        }        /**         * @param properties Sequence<KSPropertyDeclaration>         * @return String: "name1: Type1, name2: Type2"         */        private fun getParametersFromProperties(properties: Sequence<KSPropertyDeclaration>) =            properties.joinToString(", ") {                it.simpleName.asString() + ": " + getType(it, true)            }        private fun getValueGetter(pd: KSPropertyDeclaration): String {            if (pd.type.resolve().innerArguments.firstOrNull()?.type?.resolve()?.declaration?.simpleName?.asString() == "EntityID") {                return ".value"            }            return ""        }        /**         * gets type from Column<[Any]> or Column<EntityID<[Any]>>         * @param pd variable declaration with Column or Column<EntityID> types         * @return package.ClassName         */        private fun getType(            pd: KSPropertyDeclaration,            simple: Boolean = false,            removeNullable: Boolean = false        ): String {            val innerType =                pd.type.resolve().innerArguments.firstOrNull()?.type?.resolve() ?: return "ERROR(couldn't get type)"            return if (innerType.declaration.simpleName.asString() == "EntityID") {                // Column<EntityID<InnerType>>                val innerInnerType = innerType.innerArguments.firstOrNull()?.type?.resolve()                    ?: return "ERROR(couldn't get type)"                typeAndTypeRefIntoQualifiedName(innerInnerType, simple, removeNullable)            } else {                // Column<InnerType>                typeAndTypeRefIntoQualifiedName(innerType, simple, removeNullable)            }        }        /**         * Create fully qualified name for a given [KSType]         *         * @param removeNullable wether to remove the ? from the [type] or not         * @return "package.ClassName" when [simple] = false or "ClassName" when [simple] = true         */        private fun typeAndTypeRefIntoQualifiedName(            type: KSType,            simple: Boolean,            removeNullable: Boolean        ): String {            var typeName = type.toString()            if (removeNullable) typeName = type.toString().dropLastWhile { '?' == it }            return if (simple) {                typeName            } else {                val packagePrefix = type.declaration.packageName.asString().let { "$it." }                packagePrefix + typeName            }        }        override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {        }    }    data class ExposedIndex(        val unique: Boolean,        val fields: List<String>,        val name: String? = null,    )}